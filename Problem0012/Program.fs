(*
Highly divisible triangular number
Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*)
[<EntryPoint>]
let main argv = 
    let triangles level = ((level*(level+1))/2)

    let divides x y = (x % y = 0)

    (*****************************
    VERY IMPORTANT
    ******************************
    Better performances can be obtained observing that in order to determine all the factors of a number we don't have try all smaller numbers. As a matter of fact, the following is true (considering n the number to be factorized):

    if n / x = y, obviously both x and y are factors, so I don't have to probe y anymore
    If I start probing from 2 going up, I can stop probing when I have reached \sqrt n. In fact, any number bigger than \sqrt n must have been already found probing a smaller number.
    Suppose for example that we have to factor the number 36 (one of the triangle numbers):

    1 is always a factor -> factors = {1, 36}
    2 * 18 = 36 -> factors = {1, 36, 2, 18}
    3 * 12 = 36 -> factors = {1, 36, 2, 18, 3, 12 }
    4 * 9 = 36 -> factors = {1, 36, 2, 18, 3, 12, 4, 9}
    5 does not divide -> factors = {1, 36, 2, 18, 3, 12, 4, 9}
    6 * 6 = 36 -> factors = {1, 36, 2, 18, 3, 12, 4, 9, 6}
    We can stop here because if 7 divided 36 evenly, we would have already found a number x < 6 such that 7 * x = 36.
    *****************************)

    let rec GetAllFactors num index factors = 
        if (divides num index) then
            let y = num / index
            if index < y then
                GetAllFactors num (index + 1) (index::y::factors)
            else if (y = index) then
                (index::factors)
            else 
                factors
        else if index > int (sqrt (float num)) then
            factors
        else 
            GetAllFactors num (index + 1) factors

    let rec CalcFactors level factorLimit =
        let num = triangles level
        let factorCount = GetAllFactors num 1 []

        if(factorCount.Length >= factorLimit) then
            num
        else 
            CalcFactors (level+1) factorLimit

    let resolve_problem_12 = CalcFactors 1 500

    printfn "%A" resolve_problem_12
    System.Console.Read() |> ignore
    0 // return an integer exit code